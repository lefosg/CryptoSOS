## Term Assignment 
### CryptoSOS 
Τηρήθηκε το ίδιο public API με αυτό που περιγράφεται στην εκφώνηση. Οι μόνες συναρτήσεις 
που υλοποιήθηκαν εξτρά είναι όλες private, και έχουν βοηθητικό ρόλο. Γενικά, στην αρχή το 
smart contract έχει τα πεδία του (μεταβλητές), τα events, μετά ο constructor, modifiers, public 
συναρτήσεις και τέλος οι private. \
<em>Public functions</em>: 
<ul>
<li> play </li>
<li> sweepProfit </li>
<li> placeS </li>
<li> placeO </li>
<li> getGameState </li>
<li> cancel </li>
<li> tooslow </li>
</ul>
<em>Private functions</em>: 
<ul>
<li> containsSOS: καλείται μετά από κάθε κίνηση και ελέγχει εάν η παρτίδα περιέχει την 
λέξη SOS με βάση τους κανόνες (γραμμή, στήλη, διαγώνια) -> επιστρέφει bool 
(true/false, για να γίνει emit Winner) </li>
<li> outOfPlaces: ελέγχει εάν η παρτίδα πλέον δεν επιδέχεται άλλες κινήσεις, δηλαδή εάν 
γέμισε ο πίνακας με σύβολα S, O (για να γίνει emit Tie). </li>
</ul>
<em>Modifiers</em>: 
<ul>
<li> onlyOwner: ο γνωστός onlyOwner modifier, επιτρέπει μόνο στον ιδιοκτήτη του smart 
contract να κάνει την κλήση (θέτεται στον constructor ο owner). 
<li> noReentrant: λύνει το πρόβλημα της επίθεσης re-entrancy. </li>
<li> checksBeforePlacing: ελέγχει εάν είναι έγκυρη η κίνηση που πάει να γίνει σε μία θέση 
του πίνακα. </li>
<li> checksAfterPlacing: ελέγχει εάν πρέπει το παιχνίδι να τερματίσει με νίκη ή ισοπαλία, 
αλλιώς αν η παρτίδα δεν λήγει, απλά ενημερώνει την σειρά του επόμενου παίκτη που 
πρέπει να παίξει. </li>
</ul>
Όσον αφορά την tooslow, εάν την καλεί ένας παίκτης που 
τυχαίνει να είναι και ο owner, με το πέρας του 1 λεπτού η παρτίδα τελειώνει με νίκη, και μετά 
τα 5 λεπτά, με ισοπαλία, όπως αναγράφεται στην εκφώνηση. 
Υπάρχει επίσης το πρόβλημα ασφάλειας των time constraints. Αυτό περιορίζεται βάζοντας 
χρησιμοποιώντας την εντολή require για να ελέγξουμε τα χρονικά περιθώρια, πότε και ποιος 
μπορεί να κάνει μία κλήση (time locks). Στα require αυτά θα μπορούσε να προστεθεί ένα delta, 
το οποίο προστατεύει από time manipulations, αλλά δεν βρήκα κάποια πηγή να δίνει έναν 
ξεκάθαρο αριθμό για αυτό (λένε 15 δευτερόλεπτα), οπότε άφησα την υλοποίηση χωρίς αυτό.  
<h3> MultiSOS </h3>
Τα παιχνίδια όλα αποθηκεύονται σε ένα array (ονομάζεται games), το οποίο περιέχει structs 
τύπου Game. Πλέον, ότι χρειαζόμασταν στο CryptoSOS για ένα παιχνίδι, μπήκε σε αυτό το 
struct, οπότε με πολλά structs έχω πολλά παιχνίδια. Αυτό που γίνεται είναι ότι σε κάθε κλήση, 
γίνεται αναζήτηση του παιχνιδιού στο games array για να μπορέσουμε να ανανεώσουμε το 
state (π.χ., τοποθετήσεις συμβόλων). Ένας παίκτης δεν μπορεί να παίζει ταυτόχρονα δύο 
παιχνίδια, και μπορούν να παίζονται ταυτόχρονα πολλές παρτίδες. Μάλιστα, επειδή η ίδια 
διεύθυνση μπορεί να παίξει πολλά παιχνίδια (όχι ταυτόχρονα), γίνονται όλοι οι απαραίτητοι 
έλεγχοι ώστε να μην μπλεχτούν οι παρτίδες, και, π.χ., όταν μία διεύθυνση καλέσει την play, να 
ξέρει το smart contract ότι αυτή η διεύθυνση έχει ιστορικό, τελειωμένων παρτίδων όμως. <br>
Τα public functions είναι τα ίδια. <br>
<em>Επιπλέον private functions</em>:  
<ul>
<li> matchPlayerToGame: καλείται στην play, και ευθύνη της είναι να ταιριάζει έναν παίκτη 
σε ένα παιχνίδι, είτε με έναν παίκτη που περιμένει, είτε φτιάχνοντας νέο Game, και 
βάζοντας τον παίκτη αυτόν να περιμένει για δεύτερο να καλέσει την play (κάνει και 
emit τα αντίστοιχα events). </li>
<li> lookupGame: επιστρέφει ένα Game για μία δοσμένη διεύθυνση -> επιστρέφει Game 
memory </li>
<li> lookupGameStorage: επιστρέφει ένα Game για μία δοσμένη διεύθυνση -> επιστρέφει 
Game storage, για λόγους ασφάλειας φτιάχτηκε η lookupGame, να μην είναι όλες οι 
μεταβλητές storage και αλλάζει επικίνδυνα εύκολα το global state. </li>
<li> getLastGame: βρίσκει το τελευταίο παιχνίδι που έπαιξε ένας παίκτης -> επιστρέφει το 
index μέσα στον games πίνακα, όχι το ίδιο το Game. </li>
</ul>
Επιπλέον modifiers: 
<ul>
<li> gameExists: ελέγχει εάν ένα παιχνίδι υπάρχει, για να ξέρουμε ότι οι κλήσεις που 
γίνονται αντιστοιχούν σε υπάρχοντα παιχνίδια. </li>
</ul>
Για την tooslow πως αναφέρθηκε σε διάλεξη, ο όowner δεν έχει κάποια ευθύνη για να λήξει 
κάποιο παιχνίδι, την καλούν μόνο οι παίκτες ενός τρέχοντος παιχνιδιού. 
